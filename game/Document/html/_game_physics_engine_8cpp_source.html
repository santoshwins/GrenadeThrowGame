<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>GRENADE GAME: GamePhysicsEngine.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
<h1>GamePhysicsEngine.cpp</h1><a href="_game_physics_engine_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment">Bullet Continuous Collision Detection and Physics Library</span>
<a name="l00003"></a>00003 <span class="comment">Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/</span>
<a name="l00004"></a>00004 <span class="comment"></span>
<a name="l00005"></a>00005 <span class="comment">This software is provided &apos;as-is&apos;, without any express or implied warranty.</span>
<a name="l00006"></a>00006 <span class="comment">In no event will the authors be held liable for any damages arising from the use of this software.</span>
<a name="l00007"></a>00007 <span class="comment">Permission is granted to anyone to use this software for any purpose,</span>
<a name="l00008"></a>00008 <span class="comment">including commercial applications, and to alter it and redistribute it freely,</span>
<a name="l00009"></a>00009 <span class="comment">subject to the following restrictions:</span>
<a name="l00010"></a>00010 <span class="comment"></span>
<a name="l00011"></a>00011 <span class="comment">1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.</span>
<a name="l00012"></a>00012 <span class="comment">2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.</span>
<a name="l00013"></a>00013 <span class="comment">3. This notice may not be removed or altered from any source distribution.</span>
<a name="l00014"></a>00014 <span class="comment">*/</span>
<a name="l00015"></a>00015 
<a name="l00016"></a>00016 
<a name="l00017"></a>00017 <span class="preprocessor">#include &quot;<a class="code" href="_game_physics_engine_8h.html">GamePhysicsEngine.h</a>&quot;</span>
<a name="l00018"></a>00018 <span class="preprocessor">#include &lt;bullet/BulletCollision/CollisionShapes/btShapeHull.h&gt;</span>
<a name="l00019"></a>00019 <span class="preprocessor">#include &quot;iostream&quot;</span> <span class="comment">//printf debugging</span>
<a name="l00020"></a><a class="code" href="_game_physics_engine_8cpp.html#ac9c7b11b1ed1ce8e3a48fa4472d2034d">00020</a> <span class="keyword">const</span> <span class="keyword">static</span> <span class="keywordtype">float</span> <a class="code" href="_game_physics_engine_8cpp.html#ac9c7b11b1ed1ce8e3a48fa4472d2034d">friction</a>=1000.0f;
<a name="l00021"></a>00021 
<a name="l00022"></a><a class="code" href="class_game_physics_engine.html#ac7ae8854d8d47bd799033cc636cc30c7">00022</a> <a class="code" href="class_game_physics_engine.html#ac7ae8854d8d47bd799033cc636cc30c7" title="def ctor">GamePhysicsEngine::GamePhysicsEngine</a>()
<a name="l00023"></a>00023 {
<a name="l00024"></a>00024 
<a name="l00025"></a>00025     std::cout&lt;&lt;<span class="stringliteral">&quot;came in bullet engine......\n\n\n\n&quot;</span>;
<a name="l00026"></a>00026 
<a name="l00027"></a>00027     <a class="code" href="class_game_physics_engine.html#aae5433ee5d9f4f4c8374f7782ee52d75" title="flag to indicate simulation">doingSimulationInAir</a> = 0;
<a name="l00028"></a>00028     <a class="code" href="class_game_physics_engine.html#a8d70bdfffa9ed1830d0035e34d15a9ba">m_collisionConfiguration</a> = <span class="keyword">new</span> btDefaultCollisionConfiguration();
<a name="l00029"></a>00029     <a class="code" href="class_game_physics_engine.html#a693e74cacd249a5f9c5e776fc4fd9139">m_dispatcher</a> = <span class="keyword">new</span> btCollisionDispatcher(<a class="code" href="class_game_physics_engine.html#a8d70bdfffa9ed1830d0035e34d15a9ba">m_collisionConfiguration</a>);
<a name="l00030"></a>00030     <a class="code" href="class_game_physics_engine.html#ad22c6bbbdfb04fb00844760080ed1c73">m_broadphase</a> = <span class="keyword">new</span> btDbvtBroadphase();
<a name="l00032"></a>00032     btSequentialImpulseConstraintSolver* sol = <span class="keyword">new</span> btSequentialImpulseConstraintSolver;
<a name="l00033"></a>00033     <a class="code" href="class_game_physics_engine.html#abf0f440d2b548bbbde65a33b3237d248">m_solver</a> = sol;
<a name="l00034"></a>00034     <a class="code" href="class_game_physics_engine.html#a9fc605003337ab07a572bfb5bc26a081">m_dynamicsWorld</a> = <span class="keyword">new</span> btDiscreteDynamicsWorld(<a class="code" href="class_game_physics_engine.html#a693e74cacd249a5f9c5e776fc4fd9139">m_dispatcher</a>,<a class="code" href="class_game_physics_engine.html#ad22c6bbbdfb04fb00844760080ed1c73">m_broadphase</a>,<a class="code" href="class_game_physics_engine.html#abf0f440d2b548bbbde65a33b3237d248">m_solver</a>,<a class="code" href="class_game_physics_engine.html#a8d70bdfffa9ed1830d0035e34d15a9ba">m_collisionConfiguration</a>);
<a name="l00035"></a>00035     <a class="code" href="class_game_physics_engine.html#a9fc605003337ab07a572bfb5bc26a081">m_dynamicsWorld</a>-&gt;getSolverInfo().m_solverMode = SOLVER_USE_WARMSTARTING + SOLVER_SIMD;
<a name="l00036"></a>00036     <a class="code" href="class_game_physics_engine.html#a9fc605003337ab07a572bfb5bc26a081">m_dynamicsWorld</a>-&gt;setGravity(btVector3(0,-10,0));
<a name="l00037"></a>00037     <a class="code" href="class_game_physics_engine.html#a7f8cae1aa77d053b7c843457592e01dc" title="pointer to determine the collison shape">grenadeObstacleCcount</a> = 0; <span class="comment">// initial life of the grenade will be set from game logic</span>
<a name="l00038"></a>00038     <a class="code" href="class_game_physics_engine.html#aa2a56ae08a11708c47aa0ea83fdc658e" title="game won flag when grenade hits ammunition">gameWonFlag</a> = <span class="keyword">false</span>;
<a name="l00039"></a>00039 
<a name="l00040"></a>00040 
<a name="l00041"></a>00041 }
<a name="l00042"></a>00042 
<a name="l00043"></a><a class="code" href="class_game_physics_engine.html#aa38d4c2c53b59c6a8f8f4249ceb6d16c">00043</a> <a class="code" href="class_game_physics_engine.html#aa38d4c2c53b59c6a8f8f4249ceb6d16c" title="virtual dtor">GamePhysicsEngine::~GamePhysicsEngine</a>()
<a name="l00044"></a>00044 {
<a name="l00045"></a>00045 
<a name="l00046"></a>00046     <span class="comment">//cleanup in the reverse order of creation/initialization</span>
<a name="l00047"></a>00047 
<a name="l00048"></a>00048     <span class="comment">//remove the rigidbodies from the dynamics world and delete them</span>
<a name="l00049"></a>00049     <span class="keywordtype">int</span> i;
<a name="l00050"></a>00050     <span class="keywordflow">for</span> (i=<a class="code" href="class_game_physics_engine.html#a9fc605003337ab07a572bfb5bc26a081">m_dynamicsWorld</a>-&gt;getNumCollisionObjects()-1; i&gt;=0 ;i--)
<a name="l00051"></a>00051     {
<a name="l00052"></a>00052         btCollisionObject* obj = <a class="code" href="class_game_physics_engine.html#a9fc605003337ab07a572bfb5bc26a081">m_dynamicsWorld</a>-&gt;getCollisionObjectArray()[i];
<a name="l00053"></a>00053         btRigidBody* body = btRigidBody::upcast(obj);
<a name="l00054"></a>00054         <span class="keywordflow">if</span> (body &amp;&amp; body-&gt;getMotionState())
<a name="l00055"></a>00055         {
<a name="l00056"></a>00056             <span class="keyword">delete</span> body-&gt;getMotionState();
<a name="l00057"></a>00057         }
<a name="l00058"></a>00058         <a class="code" href="class_game_physics_engine.html#a9fc605003337ab07a572bfb5bc26a081">m_dynamicsWorld</a>-&gt;removeCollisionObject( obj );
<a name="l00059"></a>00059         <span class="keyword">delete</span> obj;
<a name="l00060"></a>00060     }
<a name="l00061"></a>00061 
<a name="l00062"></a>00062     <span class="comment">//delete collision shapes</span>
<a name="l00063"></a>00063     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0;j&lt;<a class="code" href="class_game_physics_engine.html#abd0b0fa78e7e178f7819f64d2bc66990" title="standard bullet variables to store collison shapes, the broadphase filter, the dispatcher...">m_collisionShapes</a>.size();j++)
<a name="l00064"></a>00064     {
<a name="l00065"></a>00065         btCollisionShape* shape = <a class="code" href="class_game_physics_engine.html#abd0b0fa78e7e178f7819f64d2bc66990" title="standard bullet variables to store collison shapes, the broadphase filter, the dispatcher...">m_collisionShapes</a>[j];
<a name="l00066"></a>00066         <span class="keyword">delete</span> shape;
<a name="l00067"></a>00067     }
<a name="l00068"></a>00068     <a class="code" href="class_game_physics_engine.html#abd0b0fa78e7e178f7819f64d2bc66990" title="standard bullet variables to store collison shapes, the broadphase filter, the dispatcher...">m_collisionShapes</a>.clear();
<a name="l00069"></a>00069 
<a name="l00070"></a>00070     <span class="keyword">delete</span> <a class="code" href="class_game_physics_engine.html#a9fc605003337ab07a572bfb5bc26a081">m_dynamicsWorld</a>;
<a name="l00071"></a>00071 
<a name="l00072"></a>00072     <span class="keyword">delete</span> <a class="code" href="class_game_physics_engine.html#abf0f440d2b548bbbde65a33b3237d248">m_solver</a>;
<a name="l00073"></a>00073 
<a name="l00074"></a>00074     <span class="keyword">delete</span> <a class="code" href="class_game_physics_engine.html#ad22c6bbbdfb04fb00844760080ed1c73">m_broadphase</a>;
<a name="l00075"></a>00075 
<a name="l00076"></a>00076     <span class="keyword">delete</span> <a class="code" href="class_game_physics_engine.html#a693e74cacd249a5f9c5e776fc4fd9139">m_dispatcher</a>;
<a name="l00077"></a>00077 
<a name="l00078"></a>00078     <span class="keyword">delete</span> <a class="code" href="class_game_physics_engine.html#a8d70bdfffa9ed1830d0035e34d15a9ba">m_collisionConfiguration</a>;
<a name="l00079"></a>00079 
<a name="l00080"></a>00080 
<a name="l00081"></a>00081 }
<a name="l00082"></a>00082 
<a name="l00083"></a>00083 
<a name="l00084"></a>00084 <span class="comment">//taken frm ode example...</span>
<a name="l00085"></a><a class="code" href="class_game_physics_engine.html#adf993ac171919c0e99dd7aecc97d8f69">00085</a> <span class="keywordtype">void</span> <a class="code" href="class_game_physics_engine.html#adf993ac171919c0e99dd7aecc97d8f69" title="gets triangulated mesh from obj">GamePhysicsEngine::getMeshFromObj</a>(ngl::Obj* _m)
<a name="l00086"></a>00086 {
<a name="l00087"></a>00087 
<a name="l00088"></a>00088 
<a name="l00089"></a>00089     <a class="code" href="class_game_physics_engine.html#aec1f95c7b202864498cbaf9a540f120b">mesh</a> = <span class="keyword">new</span> btTriangleMesh(<span class="keyword">false</span>);
<a name="l00090"></a>00090     ngl::Vec3 vv,vv1,vv2;
<a name="l00091"></a>00091     btVector3 bv1,bv2,bv3;
<a name="l00092"></a>00092 
<a name="l00093"></a>00093     std::vector&lt;ngl::Face&gt; faces=_m-&gt;getFaceList();
<a name="l00094"></a>00094     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> size1=faces.size();
<a name="l00095"></a>00095     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;size1; i++)
<a name="l00096"></a>00096     {
<a name="l00097"></a>00097 
<a name="l00098"></a>00098 
<a name="l00099"></a>00099         vv=_m-&gt;getVertexAtIndex(faces[i].m_vert[0]);
<a name="l00100"></a>00100         vv1=_m-&gt;getVertexAtIndex(faces[i].m_vert[1]);
<a name="l00101"></a>00101         vv2=_m-&gt;getVertexAtIndex(faces[i].m_vert[2]);
<a name="l00102"></a>00102         bv1 = btVector3(btScalar(vv.m_x),btScalar(vv.m_y),btScalar(vv.m_z));
<a name="l00103"></a>00103         bv2 = btVector3(btScalar(vv1.m_x),btScalar(vv1.m_y),btScalar(vv1.m_z));
<a name="l00104"></a>00104         bv3 = btVector3(btScalar(vv2.m_x),btScalar(vv2.m_y),btScalar(vv2.m_z));
<a name="l00105"></a>00105         <a class="code" href="class_game_physics_engine.html#aec1f95c7b202864498cbaf9a540f120b">mesh</a>-&gt;addTriangle(bv1,bv2,bv3);
<a name="l00106"></a>00106     }
<a name="l00107"></a>00107     <a class="code" href="class_game_physics_engine.html#a4015251785724ffd148a7e6f3fac78f5">meshShape</a> = <span class="keyword">new</span> btBvhTriangleMeshShape(<a class="code" href="class_game_physics_engine.html#aec1f95c7b202864498cbaf9a540f120b">mesh</a>,<span class="keyword">true</span>,<span class="keyword">true</span>);
<a name="l00108"></a>00108 }
<a name="l00109"></a>00109 
<a name="l00110"></a>00110 
<a name="l00111"></a><a class="code" href="class_game_physics_engine.html#a746579b65c1a680afb5ce027a7985eb2">00111</a> <span class="keywordtype">void</span> <a class="code" href="class_game_physics_engine.html#a746579b65c1a680afb5ce027a7985eb2" title="step simulation module">GamePhysicsEngine::step</a>()
<a name="l00112"></a>00112 {
<a name="l00113"></a>00113     <a class="code" href="class_game_physics_engine.html#a9fc605003337ab07a572bfb5bc26a081">m_dynamicsWorld</a>-&gt;stepSimulation(1.0/60.0,10);
<a name="l00114"></a>00114     <a class="code" href="class_game_physics_engine.html#a3c5f653f3088c5f13b0f5df401f6b574" title="sense the collison using continuous collision detection">senseCollision</a>();
<a name="l00115"></a>00115 
<a name="l00116"></a>00116 }
<a name="l00117"></a>00117 
<a name="l00118"></a>00118 
<a name="l00119"></a>00119 
<a name="l00120"></a><a class="code" href="class_game_physics_engine.html#a21fc1826e29b49db4297d086ceccede7">00120</a> <span class="keywordtype">void</span> <a class="code" href="class_game_physics_engine.html#a21fc1826e29b49db4297d086ceccede7" title="static ground plane">GamePhysicsEngine::addGround</a>(<span class="keyword">const</span> ngl::Vec3 &amp;_pos)
<a name="l00121"></a>00121 {
<a name="l00122"></a>00122         <span class="comment">//m_groundShape = new btBoxShape(btVector3(_size.m_x,_size.m_y, _size.m_z));</span>
<a name="l00123"></a>00123 
<a name="l00124"></a>00124 
<a name="l00125"></a>00125 
<a name="l00126"></a>00126         <a class="code" href="class_game_physics_engine.html#a0031c5eead021445d6c4d8bcc7627114">planeShape</a> = <span class="keyword">new</span> btStaticPlaneShape(btVector3(0,1,0),_pos.m_y);
<a name="l00127"></a>00127 
<a name="l00128"></a>00128         <a class="code" href="class_game_physics_engine.html#abd0b0fa78e7e178f7819f64d2bc66990" title="standard bullet variables to store collison shapes, the broadphase filter, the dispatcher...">m_collisionShapes</a>.push_back(<a class="code" href="class_game_physics_engine.html#a0031c5eead021445d6c4d8bcc7627114">planeShape</a>);
<a name="l00129"></a>00129 
<a name="l00130"></a>00130         btTransform groundTransform;
<a name="l00131"></a>00131         groundTransform.setIdentity();
<a name="l00132"></a>00132         {
<a name="l00133"></a>00133              btScalar mass(0.);
<a name="l00134"></a>00134              <span class="comment">//rigidbody is dynamic if and only if mass is non zero, otherwise static</span>
<a name="l00135"></a>00135              <span class="keywordtype">bool</span> isDynamic = (mass != 0.f);
<a name="l00136"></a>00136              btVector3 localInertia(0,0,0);
<a name="l00137"></a>00137              <span class="keywordflow">if</span> (isDynamic)
<a name="l00138"></a>00138                  <a class="code" href="class_game_physics_engine.html#a0031c5eead021445d6c4d8bcc7627114">planeShape</a>-&gt;calculateLocalInertia(mass,localInertia);
<a name="l00139"></a>00139              <span class="comment">//using motionstate is recommended, it provides interpolation capabilities, and only synchronizes &apos;active&apos; objects</span>
<a name="l00140"></a>00140              btDefaultMotionState* myMotionState = <span class="keyword">new</span> btDefaultMotionState(groundTransform);
<a name="l00141"></a>00141              btRigidBody::btRigidBodyConstructionInfo rbInfo(mass,myMotionState,<a class="code" href="class_game_physics_engine.html#a0031c5eead021445d6c4d8bcc7627114">planeShape</a>,localInertia);
<a name="l00142"></a>00142              btRigidBody* body = <span class="keyword">new</span> btRigidBody(rbInfo);
<a name="l00143"></a>00143              body-&gt;setFriction(<a class="code" href="_game_physics_engine_8cpp.html#ac9c7b11b1ed1ce8e3a48fa4472d2034d">friction</a>);
<a name="l00144"></a>00144              <span class="comment">//add the body to the dynamics world</span>
<a name="l00145"></a>00145              <a class="code" href="class_game_physics_engine.html#a9fc605003337ab07a572bfb5bc26a081">m_dynamicsWorld</a>-&gt;addRigidBody(body);
<a name="l00146"></a>00146         }
<a name="l00147"></a>00147 
<a name="l00148"></a>00148 }
<a name="l00149"></a>00149 
<a name="l00150"></a>00150 
<a name="l00151"></a><a class="code" href="class_game_physics_engine.html#a0225e93f6e1044fb83d742265a494adc">00151</a> <span class="keywordtype">int</span> <a class="code" href="class_game_physics_engine.html#a0225e93f6e1044fb83d742265a494adc" title="gets a particular collision shape">GamePhysicsEngine::getCollisionShape</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> _index)<span class="keyword"> const</span>
<a name="l00152"></a>00152 <span class="keyword"></span>{
<a name="l00153"></a>00153   btCollisionObject* obj = <a class="code" href="class_game_physics_engine.html#a9fc605003337ab07a572bfb5bc26a081">m_dynamicsWorld</a>-&gt;getCollisionObjectArray()[_index];
<a name="l00154"></a>00154   btCollisionShape *collisionShape = obj-&gt;getCollisionShape();
<a name="l00155"></a>00155 
<a name="l00156"></a>00156   <span class="keywordflow">return</span> collisionShape-&gt;getShapeType();
<a name="l00157"></a>00157 }
<a name="l00158"></a>00158 
<a name="l00159"></a><a class="code" href="class_game_physics_engine.html#aae2f6a7eb2b14eb346f5ca41dc2a5dc3">00159</a> ngl::Mat4 <a class="code" href="class_game_physics_engine.html#aae2f6a7eb2b14eb346f5ca41dc2a5dc3" title="gets a transformation matrix">GamePhysicsEngine::getTransformMatrix</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> _index)
<a name="l00160"></a>00160 {
<a name="l00161"></a>00161         btCollisionObject* obj = <a class="code" href="class_game_physics_engine.html#a9fc605003337ab07a572bfb5bc26a081">m_dynamicsWorld</a>-&gt;getCollisionObjectArray()[_index];
<a name="l00162"></a>00162         btRigidBody* body = btRigidBody::upcast(obj);
<a name="l00163"></a>00163         <span class="keywordflow">if</span> (body &amp;&amp; body-&gt;getMotionState())
<a name="l00164"></a>00164         {
<a name="l00165"></a>00165                 btTransform trans;
<a name="l00166"></a>00166 
<a name="l00167"></a>00167                 body-&gt;getMotionState()-&gt;getWorldTransform(trans);
<a name="l00168"></a>00168                 <span class="keywordtype">float</span> matrix[16];
<a name="l00169"></a>00169                 trans.getOpenGLMatrix(matrix);
<a name="l00170"></a>00170                 <span class="keywordflow">return</span> ngl::Mat4( matrix[0],matrix[1],matrix[2],matrix[3],
<a name="l00171"></a>00171                                   matrix[4],matrix[5],matrix[6],matrix[7],
<a name="l00172"></a>00172                                   matrix[8],matrix[9],matrix[10],matrix[11],
<a name="l00173"></a>00173                                   matrix[12],matrix[13],matrix[14],matrix[15]
<a name="l00174"></a>00174                                 );
<a name="l00175"></a>00175 
<a name="l00176"></a>00176 
<a name="l00177"></a>00177 
<a name="l00178"></a>00178         }
<a name="l00179"></a>00179 
<a name="l00180"></a>00180 }
<a name="l00181"></a>00181 
<a name="l00182"></a><a class="code" href="class_game_physics_engine.html#a168801c117e189ee9c8df5543a04a2a2">00182</a> ngl::Vec3 <a class="code" href="class_game_physics_engine.html#a168801c117e189ee9c8df5543a04a2a2" title="gets a particular position">GamePhysicsEngine::getPosition</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> _index)
<a name="l00183"></a>00183 {
<a name="l00184"></a>00184         btCollisionObject* obj = <a class="code" href="class_game_physics_engine.html#a9fc605003337ab07a572bfb5bc26a081">m_dynamicsWorld</a>-&gt;getCollisionObjectArray()[_index];
<a name="l00185"></a>00185         btRigidBody* body = btRigidBody::upcast(obj);
<a name="l00186"></a>00186         <span class="keywordflow">if</span> (body &amp;&amp; body-&gt;getMotionState())
<a name="l00187"></a>00187         {
<a name="l00188"></a>00188                 btTransform trans;
<a name="l00189"></a>00189                 body-&gt;getMotionState()-&gt;getWorldTransform(trans);
<a name="l00190"></a>00190                 <span class="keywordflow">return</span> ngl::Vec3(trans.getOrigin().getX(),
<a name="l00191"></a>00191                                                                                  trans.getOrigin().getY(),
<a name="l00192"></a>00192                                                                                  trans.getOrigin().getZ()
<a name="l00193"></a>00193                                                                                 );
<a name="l00194"></a>00194         }
<a name="l00195"></a>00195 }
<a name="l00196"></a>00196 
<a name="l00197"></a>00197 
<a name="l00198"></a>00198 
<a name="l00199"></a><a class="code" href="class_game_physics_engine.html#a32798b64c0a21d01d5a0f658ccda1c95">00199</a> <span class="keywordtype">void</span> <a class="code" href="class_game_physics_engine.html#a32798b64c0a21d01d5a0f658ccda1c95" title="box shaped coll box for ammunition">GamePhysicsEngine::addBox</a>(<span class="keyword">const</span> ngl::Vec3 &amp;_pos, ngl::Vec4 _scale, <a class="code" href="_game_physics_engine_8h.html#abf2074b1ffe7b332a3eed56160e373b2">boundingExtras</a> _inputRbodyType)
<a name="l00200"></a>00200 {
<a name="l00201"></a>00201     <span class="comment">//create a dynamic rigidbody</span>
<a name="l00202"></a>00202 
<a name="l00203"></a>00203     btCollisionShape* colShape;
<a name="l00204"></a>00204 
<a name="l00205"></a>00205 
<a name="l00206"></a>00206     <span class="comment">// this condition might look redundant, but this is needed to differentiate bewtween similar collision shapes by setting our own pointer into the collision shape depending on the object</span>
<a name="l00207"></a>00207     <span class="keywordflow">if</span> (_inputRbodyType == <a class="code" href="_game_physics_engine_8h.html#abf2074b1ffe7b332a3eed56160e373b2a44980b135e1756c9a2ec55cf8f4cdd28">CRATE_AMMUNITION</a>)
<a name="l00208"></a>00208     {
<a name="l00209"></a>00209        colShape  = <span class="keyword">new</span> btBoxShape(btVector3(_scale.m_x,_scale.m_y,_scale.m_z));
<a name="l00210"></a>00210         <a class="code" href="class_game_physics_engine.html#a306d59118f46eddb5e6e335de6cc64fe" title="pointer to determine the collison shape">boxptr</a> = <span class="keyword">this</span>;
<a name="l00211"></a>00211     }
<a name="l00212"></a>00212     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (_inputRbodyType == <a class="code" href="_game_physics_engine_8h.html#abf2074b1ffe7b332a3eed56160e373b2a1dec48f524bb3970f60872b91697740e">INVISIBLE_WALL</a>)
<a name="l00213"></a>00213     {
<a name="l00214"></a>00214         colShape = <span class="keyword">new</span> btBoxShape(btVector3(_scale.m_x,_scale.m_y,_scale.m_z));
<a name="l00215"></a>00215          <a class="code" href="class_game_physics_engine.html#a6e6e7e90ebdaa47975ab1225c96a6b5c" title="pointer to determine the collison shape">wallptr</a> = 0;
<a name="l00216"></a>00216     }
<a name="l00217"></a>00217     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (_inputRbodyType == <a class="code" href="_game_physics_engine_8h.html#abf2074b1ffe7b332a3eed56160e373b2a7154d4883e8234b6cb07ef5490b2f772">INVISIBLE_CAM_WALL</a>)
<a name="l00218"></a>00218     {
<a name="l00219"></a>00219         colShape = <span class="keyword">new</span> btBoxShape(btVector3(_scale.m_x,_scale.m_y,_scale.m_z));
<a name="l00220"></a>00220          <a class="code" href="class_game_physics_engine.html#a6e6e7e90ebdaa47975ab1225c96a6b5c" title="pointer to determine the collison shape">wallptr</a> = 0;
<a name="l00221"></a>00221     }
<a name="l00222"></a>00222 
<a name="l00223"></a>00223 
<a name="l00224"></a>00224 
<a name="l00225"></a>00225 
<a name="l00226"></a>00226 
<a name="l00227"></a>00227     <span class="comment">//btCollisionShape* colShape = new  btCapsuleShape(0.5,1.0);//  btBoxShape(btVector3(_rad/2.0,_rad/2.0,_rad/2.0));</span>
<a name="l00228"></a>00228 
<a name="l00229"></a>00229     <a class="code" href="class_game_physics_engine.html#abd0b0fa78e7e178f7819f64d2bc66990" title="standard bullet variables to store collison shapes, the broadphase filter, the dispatcher...">m_collisionShapes</a>.push_back(colShape);
<a name="l00230"></a>00230 
<a name="l00232"></a>00232     btTransform startTransform;
<a name="l00233"></a>00233     startTransform.setIdentity();
<a name="l00234"></a>00234     btScalar  mass(10.f);
<a name="l00235"></a>00235     btVector3 localInertia(0,0,0);
<a name="l00236"></a>00236     colShape-&gt;calculateLocalInertia(mass,localInertia);
<a name="l00237"></a>00237     startTransform.setOrigin(btVector3(_pos.m_x,_pos.m_y,_pos.m_z));
<a name="l00238"></a>00238     <span class="comment">//using motionstate is recommended, it provides interpolation capabilities, and only synchronizes &apos;active&apos; objects</span>
<a name="l00239"></a>00239     btDefaultMotionState* myMotionState = <span class="keyword">new</span> btDefaultMotionState(startTransform);
<a name="l00240"></a>00240     btRigidBody::btRigidBodyConstructionInfo rbInfo(mass,myMotionState,colShape,localInertia);
<a name="l00241"></a>00241     rbInfo.m_restitution = 0.8f;
<a name="l00242"></a>00242     rbInfo.m_friction = 100.5f;
<a name="l00243"></a>00243     rbInfo.m_additionalAngularDampingFactor=4.0;
<a name="l00244"></a>00244     rbInfo.m_additionalDamping=5.0;
<a name="l00245"></a>00245     btRigidBody* body = <span class="keyword">new</span> btRigidBody(rbInfo);
<a name="l00246"></a>00246     body-&gt;setFriction(<a class="code" href="_game_physics_engine_8cpp.html#ac9c7b11b1ed1ce8e3a48fa4472d2034d">friction</a>);
<a name="l00247"></a>00247     <span class="comment">//body-&gt;setActivationState(ISLAND_SLEEPING);</span>
<a name="l00248"></a>00248     body-&gt;setLinearFactor(btVector3(1,0,1));
<a name="l00249"></a>00249     body-&gt;setAngularFactor(btVector3(0,1,0));
<a name="l00250"></a>00250 
<a name="l00251"></a>00251 
<a name="l00252"></a>00252     <span class="keywordflow">if</span> (_inputRbodyType == <a class="code" href="_game_physics_engine_8h.html#abf2074b1ffe7b332a3eed56160e373b2a44980b135e1756c9a2ec55cf8f4cdd28">CRATE_AMMUNITION</a>)
<a name="l00253"></a>00253     {
<a name="l00254"></a>00254         body-&gt;setUserPointer(<a class="code" href="class_game_physics_engine.html#a306d59118f46eddb5e6e335de6cc64fe" title="pointer to determine the collison shape">boxptr</a>);
<a name="l00255"></a>00255     }
<a name="l00256"></a>00256     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (_inputRbodyType == <a class="code" href="_game_physics_engine_8h.html#abf2074b1ffe7b332a3eed56160e373b2a1dec48f524bb3970f60872b91697740e">INVISIBLE_WALL</a>)
<a name="l00257"></a>00257     {
<a name="l00258"></a>00258         body-&gt;setUserPointer(<a class="code" href="class_game_physics_engine.html#a6e6e7e90ebdaa47975ab1225c96a6b5c" title="pointer to determine the collison shape">wallptr</a>);
<a name="l00259"></a>00259     }
<a name="l00260"></a>00260 
<a name="l00261"></a>00261     body-&gt;setCollisionFlags(btCollisionObject::CF_STATIC_OBJECT);
<a name="l00262"></a>00262     <a class="code" href="class_game_physics_engine.html#a9fc605003337ab07a572bfb5bc26a081">m_dynamicsWorld</a>-&gt;addRigidBody(body);
<a name="l00263"></a>00263 
<a name="l00264"></a>00264 
<a name="l00265"></a>00265 }
<a name="l00266"></a>00266 
<a name="l00267"></a>00267 
<a name="l00268"></a>00268 
<a name="l00269"></a><a class="code" href="class_game_physics_engine.html#a2e3dcee2be1da7249e5ba1d7b7e95348">00269</a> <span class="keywordtype">void</span> <a class="code" href="class_game_physics_engine.html#a2e3dcee2be1da7249e5ba1d7b7e95348" title="add sky box">GamePhysicsEngine::addSkyBox</a>(<span class="keyword">const</span> ngl::Vec3 &amp;_pos, ngl::Vec4 _bounds)
<a name="l00270"></a>00270 {
<a name="l00271"></a>00271     <span class="comment">//create a dynamic rigidbody</span>
<a name="l00272"></a>00272 
<a name="l00273"></a>00273 
<a name="l00274"></a>00274 
<a name="l00275"></a>00275     btCollisionShape* colShape = <span class="keyword">new</span> btBoxShape(btVector3(_bounds.m_x,_bounds.m_y,_bounds.m_z));
<a name="l00276"></a>00276 
<a name="l00277"></a>00277     <a class="code" href="class_game_physics_engine.html#abd0b0fa78e7e178f7819f64d2bc66990" title="standard bullet variables to store collison shapes, the broadphase filter, the dispatcher...">m_collisionShapes</a>.push_back(colShape);
<a name="l00278"></a>00278 
<a name="l00280"></a>00280     btTransform startTransform;
<a name="l00281"></a>00281     startTransform.setIdentity();
<a name="l00282"></a>00282     btScalar  mass(1.f);
<a name="l00283"></a>00283     btVector3 localInertia(0,0,0);
<a name="l00284"></a>00284     colShape-&gt;calculateLocalInertia(mass,localInertia);
<a name="l00285"></a>00285     startTransform.setOrigin(btVector3(_pos.m_x,_pos.m_y,_pos.m_z));
<a name="l00286"></a>00286     <span class="comment">//using motionstate is recommended, it provides interpolation capabilities, and only synchronizes &apos;active&apos; objects</span>
<a name="l00287"></a>00287     btDefaultMotionState* myMotionState = <span class="keyword">new</span> btDefaultMotionState(startTransform);
<a name="l00288"></a>00288     btRigidBody::btRigidBodyConstructionInfo rbInfo(mass,myMotionState,colShape,localInertia);
<a name="l00289"></a>00289     rbInfo.m_restitution = 0.8f;
<a name="l00290"></a>00290     rbInfo.m_friction = 100.5f;
<a name="l00291"></a>00291     rbInfo.m_additionalAngularDampingFactor=4.0;
<a name="l00292"></a>00292     rbInfo.m_additionalDamping=5.0;
<a name="l00293"></a>00293     btRigidBody* body = <span class="keyword">new</span> btRigidBody(rbInfo);
<a name="l00294"></a>00294     body-&gt;setFriction(<a class="code" href="_game_physics_engine_8cpp.html#ac9c7b11b1ed1ce8e3a48fa4472d2034d">friction</a>);
<a name="l00295"></a>00295     body-&gt;setActivationState(ISLAND_SLEEPING);
<a name="l00296"></a>00296     body-&gt;setCollisionFlags(btCollisionObject::CF_STATIC_OBJECT);
<a name="l00297"></a>00297     <a class="code" href="class_game_physics_engine.html#a9fc605003337ab07a572bfb5bc26a081">m_dynamicsWorld</a>-&gt;addRigidBody(body);
<a name="l00298"></a>00298 }
<a name="l00299"></a>00299 
<a name="l00300"></a>00300 
<a name="l00301"></a><a class="code" href="class_game_physics_engine.html#a9d202b719d2c29b47bb2dece22836ef7">00301</a> <span class="keywordtype">void</span> <a class="code" href="class_game_physics_engine.html#a9d202b719d2c29b47bb2dece22836ef7" title="used in level3 to move tanks">GamePhysicsEngine::moveBox</a>(<span class="keywordtype">int</span> _bodyreference, <span class="keywordtype">float</span> _inputimpulse)
<a name="l00302"></a>00302 {
<a name="l00303"></a>00303     btCollisionObject* obj = <a class="code" href="class_game_physics_engine.html#a9fc605003337ab07a572bfb5bc26a081">m_dynamicsWorld</a>-&gt;getCollisionObjectArray()[_bodyreference];
<a name="l00304"></a>00304     btRigidBody* body = btRigidBody::upcast(obj);
<a name="l00305"></a>00305 
<a name="l00306"></a>00306     body-&gt;setActivationState(ACTIVE_TAG);
<a name="l00307"></a>00307 
<a name="l00308"></a>00308     body-&gt;setGravity(btVector3(0,-10,0));
<a name="l00309"></a>00309 
<a name="l00310"></a>00310     <span class="keywordflow">if</span> (body &amp;&amp; body-&gt;getMotionState())
<a name="l00311"></a>00311     {
<a name="l00312"></a>00312             btTransform trans = body-&gt;getWorldTransform();
<a name="l00313"></a>00313             trans.getOrigin() += (btVector3((_bodyreference * _inputimpulse),0, 0 ));
<a name="l00314"></a>00314             trans.setRotation(trans.getRotation() + btQuaternion(0,1,0,(_bodyreference * _inputimpulse)));
<a name="l00315"></a>00315             body-&gt;setWorldTransform(trans);
<a name="l00316"></a>00316     }
<a name="l00317"></a>00317 }
<a name="l00318"></a>00318 
<a name="l00319"></a>00319 
<a name="l00320"></a><a class="code" href="class_game_physics_engine.html#aa54e927b82a5aeec40e72b1915a3ba10">00320</a> <span class="keywordtype">void</span> <a class="code" href="class_game_physics_engine.html#aa54e927b82a5aeec40e72b1915a3ba10" title="add our convex player">GamePhysicsEngine::addConvexGrenade</a>(<span class="keyword">const</span> ngl::Vec3 &amp;_pos)
<a name="l00321"></a>00321 {
<a name="l00322"></a>00322 
<a name="l00323"></a>00323         <a class="code" href="class_game_physics_engine.html#aa387b5db0a71d16bd6a4d27be05e72d7" title="temp obj mesh">tempObj</a> = <span class="keyword">new</span> ngl::Obj(<span class="stringliteral">&quot;models/Grenade.obj&quot;</span>,<span class="stringliteral">&quot;textures/Grenade.tga&quot;</span>);
<a name="l00324"></a>00324         <a class="code" href="class_game_physics_engine.html#adf993ac171919c0e99dd7aecc97d8f69" title="gets triangulated mesh from obj">getMeshFromObj</a>(<a class="code" href="class_game_physics_engine.html#aa387b5db0a71d16bd6a4d27be05e72d7" title="temp obj mesh">tempObj</a>);
<a name="l00325"></a>00325         <a class="code" href="class_game_physics_engine.html#af514ddb7f22288d2d6da48ce1e89c822" title="pointer to determine the collison shape">grenadeptr</a> = (<span class="keyword">this</span> + 1);
<a name="l00326"></a>00326 
<a name="l00327"></a>00327         btConvexShape* tmpConvexShape = <span class="keyword">new</span> btConvexTriangleMeshShape(<a class="code" href="class_game_physics_engine.html#aec1f95c7b202864498cbaf9a540f120b">mesh</a>);
<a name="l00328"></a>00328 
<a name="l00329"></a>00329         std::cout&lt;&lt;<span class="stringliteral">&quot;reducing vertices by creating a convex hull\n&quot;</span>;
<a name="l00330"></a>00330         <span class="comment">//create a hull approximation</span>
<a name="l00331"></a>00331         btShapeHull* hull = <span class="keyword">new</span> btShapeHull(tmpConvexShape);
<a name="l00332"></a>00332         btScalar margin = tmpConvexShape-&gt;getMargin();
<a name="l00333"></a>00333         hull-&gt;buildHull(margin);
<a name="l00334"></a>00334         btConvexHullShape* simplifiedConvexShape = <span class="keyword">new</span> btConvexHullShape((btScalar*)hull-&gt;getVertexPointer(),hull-&gt;numVertices());
<a name="l00335"></a>00335         std::cout&lt;&lt;<span class="stringliteral">&quot;new numTriangles = &quot;</span>&lt;&lt; hull-&gt;numTriangles();
<a name="l00336"></a>00336         std::cout&lt;&lt;<span class="stringliteral">&quot;new numIndices = &quot;</span>&lt;&lt;hull-&gt;numIndices();
<a name="l00337"></a>00337         std::cout&lt;&lt;<span class="stringliteral">&quot;new numVertices = &quot;</span>&lt;&lt; hull-&gt;numVertices();
<a name="l00338"></a>00338         <a class="code" href="class_game_physics_engine.html#abd0b0fa78e7e178f7819f64d2bc66990" title="standard bullet variables to store collison shapes, the broadphase filter, the dispatcher...">m_collisionShapes</a>.push_back(simplifiedConvexShape);
<a name="l00340"></a>00340         btTransform startTransform;
<a name="l00341"></a>00341         startTransform.setIdentity();
<a name="l00342"></a>00342         btScalar  mass(3.f);
<a name="l00343"></a>00343         btVector3 localInertia(0,0,0);
<a name="l00344"></a>00344         simplifiedConvexShape-&gt;calculateLocalInertia(mass,localInertia);
<a name="l00345"></a>00345         startTransform.setOrigin(btVector3(_pos.m_x,_pos.m_y,_pos.m_z));
<a name="l00346"></a>00346         <span class="comment">//using motionstate is recommended, it provides interpolation capabilities, and only synchronizes &apos;active&apos; objects</span>
<a name="l00347"></a>00347         btDefaultMotionState* myMotionState = <span class="keyword">new</span> btDefaultMotionState(startTransform);
<a name="l00348"></a>00348         btRigidBody::btRigidBodyConstructionInfo rbInfo(mass,myMotionState,simplifiedConvexShape,localInertia);
<a name="l00349"></a>00349         rbInfo.m_restitution = 0.8f;
<a name="l00350"></a>00350         rbInfo.m_friction = 100.5f;
<a name="l00351"></a>00351         rbInfo.m_additionalAngularDampingFactor=4.0;
<a name="l00352"></a>00352         rbInfo.m_additionalDamping=5.0;
<a name="l00353"></a>00353         btRigidBody* body = <span class="keyword">new</span> btRigidBody(rbInfo);
<a name="l00354"></a>00354         body-&gt;setFriction(<a class="code" href="_game_physics_engine_8cpp.html#ac9c7b11b1ed1ce8e3a48fa4472d2034d">friction</a>);
<a name="l00355"></a>00355         body-&gt;setActivationState(DISABLE_DEACTIVATION);
<a name="l00356"></a>00356         body-&gt;setUserPointer(<a class="code" href="class_game_physics_engine.html#af514ddb7f22288d2d6da48ce1e89c822" title="pointer to determine the collison shape">grenadeptr</a>);
<a name="l00357"></a>00357         std::cout&lt;&lt;<span class="stringliteral">&quot;ptr is &quot;</span>&lt;&lt;body-&gt;getUserPointer();
<a name="l00358"></a>00358         <a class="code" href="class_game_physics_engine.html#a9fc605003337ab07a572bfb5bc26a081">m_dynamicsWorld</a>-&gt;addRigidBody(body);
<a name="l00359"></a>00359 
<a name="l00360"></a>00360 }
<a name="l00361"></a>00361 
<a name="l00362"></a>00362 
<a name="l00363"></a>00363 
<a name="l00364"></a><a class="code" href="class_game_physics_engine.html#a13f056c76293c579fede557c569d4ba9">00364</a> <span class="keywordtype">void</span> <a class="code" href="class_game_physics_engine.html#a13f056c76293c579fede557c569d4ba9" title="add our convex tank">GamePhysicsEngine::addConvexStones</a>(<span class="keyword">const</span> ngl::Vec3 &amp;_pos, <span class="keyword">const</span> ngl::Vec3 &amp;_rot)
<a name="l00365"></a>00365 {
<a name="l00366"></a>00366 
<a name="l00367"></a>00367         <a class="code" href="class_game_physics_engine.html#aa387b5db0a71d16bd6a4d27be05e72d7" title="temp obj mesh">tempObj</a> = <span class="keyword">new</span> ngl::Obj(<span class="stringliteral">&quot;models/truck.obj&quot;</span>,<span class="stringliteral">&quot;textures/Grenade.tga&quot;</span>);
<a name="l00368"></a>00368         <a class="code" href="class_game_physics_engine.html#adf993ac171919c0e99dd7aecc97d8f69" title="gets triangulated mesh from obj">getMeshFromObj</a>(<a class="code" href="class_game_physics_engine.html#aa387b5db0a71d16bd6a4d27be05e72d7" title="temp obj mesh">tempObj</a>);
<a name="l00369"></a>00369 
<a name="l00370"></a>00370         <a class="code" href="class_game_physics_engine.html#ab6fb75dc428bfcdc3f925187444883df" title="pointer to determine the collison shape">obstacleptr</a> = (<span class="keyword">this</span> + 2);
<a name="l00371"></a>00371 
<a name="l00372"></a>00372         btConvexShape* tmpConvexShape = <span class="keyword">new</span> btConvexTriangleMeshShape(<a class="code" href="class_game_physics_engine.html#aec1f95c7b202864498cbaf9a540f120b">mesh</a>);
<a name="l00373"></a>00373         std::cout&lt;&lt;<span class="stringliteral">&quot;reducing vertices by creating a convex hull\n&quot;</span>;
<a name="l00374"></a>00374         <span class="comment">//create a hull approximation</span>
<a name="l00375"></a>00375         btShapeHull* hull = <span class="keyword">new</span> btShapeHull(tmpConvexShape);
<a name="l00376"></a>00376         btScalar margin = tmpConvexShape-&gt;getMargin();
<a name="l00377"></a>00377         hull-&gt;buildHull(margin);
<a name="l00378"></a>00378         btConvexHullShape* simplifiedConvexShape = <span class="keyword">new</span> btConvexHullShape((btScalar*)hull-&gt;getVertexPointer(),hull-&gt;numVertices());
<a name="l00379"></a>00379         std::cout&lt;&lt;<span class="stringliteral">&quot;new numTriangles = &quot;</span>&lt;&lt; hull-&gt;numTriangles();
<a name="l00380"></a>00380         std::cout&lt;&lt;<span class="stringliteral">&quot;new numIndices = &quot;</span>&lt;&lt;hull-&gt;numIndices();
<a name="l00381"></a>00381         std::cout&lt;&lt;<span class="stringliteral">&quot;new numVertices = &quot;</span>&lt;&lt; hull-&gt;numVertices();
<a name="l00382"></a>00382         <a class="code" href="class_game_physics_engine.html#abd0b0fa78e7e178f7819f64d2bc66990" title="standard bullet variables to store collison shapes, the broadphase filter, the dispatcher...">m_collisionShapes</a>.push_back(simplifiedConvexShape);
<a name="l00383"></a>00383 
<a name="l00384"></a>00384         btTransform startTransform;
<a name="l00385"></a>00385         startTransform.setIdentity();
<a name="l00386"></a>00386 
<a name="l00387"></a>00387         btScalar  mass(10.f);
<a name="l00388"></a>00388 
<a name="l00389"></a>00389 
<a name="l00390"></a>00390         btVector3 localInertia(0,0,0);
<a name="l00391"></a>00391         simplifiedConvexShape-&gt;calculateLocalInertia(mass,localInertia);
<a name="l00392"></a>00392         startTransform.setOrigin(btVector3(_pos.m_x,_pos.m_y,_pos.m_z));
<a name="l00393"></a>00393         startTransform.setRotation(btQuaternion(0,1,0,_rot.m_y));
<a name="l00394"></a>00394 
<a name="l00395"></a>00395         <span class="comment">//using motionstate is recommended, it provides interpolation capabilities, and only synchronizes &apos;active&apos; objects</span>
<a name="l00396"></a>00396         btDefaultMotionState* myMotionState = <span class="keyword">new</span> btDefaultMotionState(startTransform);
<a name="l00397"></a>00397 
<a name="l00398"></a>00398         btRigidBody::btRigidBodyConstructionInfo rbInfo(mass,myMotionState,simplifiedConvexShape,localInertia);
<a name="l00399"></a>00399         rbInfo.m_restitution = 0.8f;
<a name="l00400"></a>00400         rbInfo.m_friction = 100.5f;
<a name="l00401"></a>00401         rbInfo.m_additionalAngularDampingFactor=4.0;
<a name="l00402"></a>00402         rbInfo.m_additionalDamping=5.0;
<a name="l00403"></a>00403         btRigidBody* body = <span class="keyword">new</span> btRigidBody(rbInfo);
<a name="l00404"></a>00404         body-&gt;setFriction(<a class="code" href="_game_physics_engine_8cpp.html#ac9c7b11b1ed1ce8e3a48fa4472d2034d">friction</a>);
<a name="l00405"></a>00405 
<a name="l00406"></a>00406         body-&gt;setLinearFactor(btVector3(1,0,1));
<a name="l00407"></a>00407         body-&gt;setAngularFactor(btVector3(0,1,0));
<a name="l00408"></a>00408 
<a name="l00409"></a>00409         body-&gt;setUserPointer(<a class="code" href="class_game_physics_engine.html#ab6fb75dc428bfcdc3f925187444883df" title="pointer to determine the collison shape">obstacleptr</a>);
<a name="l00410"></a>00410 
<a name="l00411"></a>00411         std::cout&lt;&lt;<span class="stringliteral">&quot;ptr is &quot;</span>&lt;&lt;body-&gt;getUserPointer();
<a name="l00412"></a>00412         <a class="code" href="class_game_physics_engine.html#a9fc605003337ab07a572bfb5bc26a081">m_dynamicsWorld</a>-&gt;addRigidBody(body);
<a name="l00413"></a>00413 
<a name="l00414"></a>00414 }
<a name="l00415"></a>00415 
<a name="l00416"></a>00416 
<a name="l00417"></a><a class="code" href="class_game_physics_engine.html#a3f7a0b35ddcbe77c441ec42ef320b1e6">00417</a> <span class="keywordtype">void</span> <a class="code" href="class_game_physics_engine.html#a3f7a0b35ddcbe77c441ec42ef320b1e6" title="add impulse to player">GamePhysicsEngine::moveGrenade</a>(<span class="keywordtype">int</span> _inputRightLeftAccumulated, <span class="keywordtype">int</span> _inputUpDownAccumulated, <span class="keywordtype">int</span> _inputWindValue )
<a name="l00418"></a>00418 {
<a name="l00419"></a>00419 
<a name="l00420"></a>00420 
<a name="l00421"></a>00421     <span class="keywordflow">if</span> (_inputUpDownAccumulated != 0)
<a name="l00422"></a>00422     {
<a name="l00423"></a>00423         btCollisionObject* obj = <a class="code" href="class_game_physics_engine.html#a9fc605003337ab07a572bfb5bc26a081">m_dynamicsWorld</a>-&gt;getCollisionObjectArray()[0];
<a name="l00424"></a>00424         btRigidBody* body = btRigidBody::upcast(obj);
<a name="l00425"></a>00425         <span class="keywordflow">if</span> (body &amp;&amp; body-&gt;getMotionState())
<a name="l00426"></a>00426         {
<a name="l00427"></a>00427             btTransform trans = body-&gt;getWorldTransform();
<a name="l00428"></a>00428 
<a name="l00429"></a>00429             <span class="comment">// if level3, get wind as input and set x of gravity to that input</span>
<a name="l00430"></a>00430             <span class="keywordflow">if</span> (_inputWindValue != 0)
<a name="l00431"></a>00431             {
<a name="l00432"></a>00432             body-&gt;setGravity(btVector3((_inputWindValue),-10,0));
<a name="l00433"></a>00433             }
<a name="l00434"></a>00434 
<a name="l00435"></a>00435               body-&gt;applyCentralImpulse(btVector3(_inputRightLeftAccumulated,_inputUpDownAccumulated,_inputUpDownAccumulated));
<a name="l00436"></a>00436 
<a name="l00437"></a>00437 
<a name="l00438"></a>00438 
<a name="l00439"></a>00439         }
<a name="l00440"></a>00440     }
<a name="l00441"></a>00441 
<a name="l00442"></a>00442 
<a name="l00443"></a>00443 }
<a name="l00444"></a>00444 
<a name="l00445"></a>00445 
<a name="l00446"></a><a class="code" href="class_game_physics_engine.html#a3c5f653f3088c5f13b0f5df401f6b574">00446</a> <span class="keywordtype">void</span> <a class="code" href="class_game_physics_engine.html#a3c5f653f3088c5f13b0f5df401f6b574" title="sense the collison using continuous collision detection">GamePhysicsEngine::senseCollision</a>()
<a name="l00447"></a>00447 {
<a name="l00448"></a>00448     <span class="keywordtype">int</span> numContacts = 0;
<a name="l00449"></a>00449 
<a name="l00450"></a>00450     <span class="keywordtype">int</span> numManifolds = <a class="code" href="class_game_physics_engine.html#a693e74cacd249a5f9c5e776fc4fd9139">m_dispatcher</a>-&gt;getNumManifolds();
<a name="l00451"></a>00451 
<a name="l00452"></a>00452     <span class="comment">//std::cout&lt;&lt;&quot;number of Manifolds is &quot;&lt;&lt;numManifolds&lt;&lt;std::endl;</span>
<a name="l00453"></a>00453 
<a name="l00454"></a>00454     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;numManifolds;i++)
<a name="l00455"></a>00455     {
<a name="l00456"></a>00456 
<a name="l00457"></a>00457         btPersistentManifold* contactManifold = <a class="code" href="class_game_physics_engine.html#a693e74cacd249a5f9c5e776fc4fd9139">m_dispatcher</a>-&gt;getManifoldByIndexInternal(i);
<a name="l00458"></a>00458 
<a name="l00459"></a>00459         btCollisionObject* obA = <span class="keyword">static_cast&lt;</span>btCollisionObject*<span class="keyword">&gt;</span>(contactManifold-&gt;getBody0());
<a name="l00460"></a>00460 
<a name="l00461"></a>00461         btCollisionObject* obB = <span class="keyword">static_cast&lt;</span>btCollisionObject*<span class="keyword">&gt;</span>(contactManifold-&gt;getBody1());
<a name="l00462"></a>00462 
<a name="l00463"></a>00463         numContacts = contactManifold-&gt;getNumContacts();
<a name="l00464"></a>00464 
<a name="l00465"></a>00465 
<a name="l00466"></a>00466         <span class="keywordflow">if</span> ((numContacts == 1) &amp;&amp; (<a class="code" href="class_game_physics_engine.html#aae5433ee5d9f4f4c8374f7782ee52d75" title="flag to indicate simulation">doingSimulationInAir</a> == 1))
<a name="l00467"></a>00467         {
<a name="l00468"></a>00468             <span class="keywordflow">if</span>((obA-&gt;getCollisionShape()-&gt;getShapeType() == CONVEX_HULL_SHAPE_PROXYTYPE) &amp;&amp; (obB-&gt;getCollisionShape()-&gt;getShapeType() == CONVEX_HULL_SHAPE_PROXYTYPE))
<a name="l00469"></a>00469             {
<a name="l00470"></a>00470 
<a name="l00471"></a>00471                 <span class="keywordflow">if</span>((obA-&gt;getUserPointer() == <a class="code" href="class_game_physics_engine.html#af514ddb7f22288d2d6da48ce1e89c822" title="pointer to determine the collison shape">grenadeptr</a>) &amp;&amp; (obB-&gt;getUserPointer() == <a class="code" href="class_game_physics_engine.html#ab6fb75dc428bfcdc3f925187444883df" title="pointer to determine the collison shape">obstacleptr</a>))
<a name="l00472"></a>00472                 {
<a name="l00473"></a>00473                     std::cout&lt;&lt;<span class="stringliteral">&quot;yesssss i hit youuuuuu....&quot;</span>;
<a name="l00474"></a>00474 
<a name="l00475"></a>00475                     obA-&gt;setCollisionFlags(btCollisionObject::CF_NO_CONTACT_RESPONSE|btCollisionObject::CF_DISABLE_SPU_COLLISION_PROCESSING);
<a name="l00476"></a>00476                     obB-&gt;setCollisionFlags(btCollisionObject::CF_DISABLE_SPU_COLLISION_PROCESSING);
<a name="l00477"></a>00477 
<a name="l00478"></a>00478                     <a class="code" href="class_game_physics_engine.html#a3a8380a8fb5387d5548eae4a50f6041b" title="sets the grenade obstacle count value used for scoring">setGrenadeObstacleCcount</a>(0);
<a name="l00479"></a>00479                     <span class="keywordflow">break</span>; <span class="comment">// this is reqd to exit, else, numcontacts remains as one for quite a while which will lead to deduction of lives more than once</span>
<a name="l00480"></a>00480                 }
<a name="l00481"></a>00481         }
<a name="l00482"></a>00482         <span class="keywordflow">if</span>((obA-&gt;getCollisionShape()-&gt;getShapeType() == CONVEX_HULL_SHAPE_PROXYTYPE) &amp;&amp; (obB-&gt;getCollisionShape()-&gt;getShapeType() == BOX_SHAPE_PROXYTYPE))
<a name="l00483"></a>00483         {
<a name="l00484"></a>00484             <span class="keywordflow">if</span>((obA-&gt;getUserPointer() == <a class="code" href="class_game_physics_engine.html#af514ddb7f22288d2d6da48ce1e89c822" title="pointer to determine the collison shape">grenadeptr</a>) &amp;&amp; (obB-&gt;getUserPointer() == <a class="code" href="class_game_physics_engine.html#a306d59118f46eddb5e6e335de6cc64fe" title="pointer to determine the collison shape">boxptr</a>))
<a name="l00485"></a>00485             {
<a name="l00486"></a>00486                 std::cout&lt;&lt;<span class="stringliteral">&quot;oh, yeah..you won...&quot;</span>;
<a name="l00487"></a>00487                 <a class="code" href="class_game_physics_engine.html#a39280c8be4b9320e672778fe95b90956" title="sets the game won flag when grande hits amunition box">setGameWonFlag</a>();
<a name="l00488"></a>00488                 <span class="keywordflow">break</span>;
<a name="l00489"></a>00489             }
<a name="l00490"></a>00490         }
<a name="l00491"></a>00491 
<a name="l00492"></a>00492     }
<a name="l00493"></a>00493 
<a name="l00494"></a>00494     <span class="keywordflow">if</span> ((numContacts == 0) &amp;&amp; (obA-&gt;getUserPointer() == <a class="code" href="class_game_physics_engine.html#af514ddb7f22288d2d6da48ce1e89c822" title="pointer to determine the collison shape">grenadeptr</a>) &amp;&amp; (obA-&gt;getCollisionShape()-&gt;getShapeType() == CONVEX_HULL_SHAPE_PROXYTYPE) &amp;&amp; (obB-&gt;getCollisionShape()-&gt;getShapeType() == STATIC_PLANE_PROXYTYPE))
<a name="l00495"></a>00495 
<a name="l00496"></a>00496     {
<a name="l00497"></a>00497 
<a name="l00498"></a>00498       obA-&gt;setCollisionFlags(btCollisionObject::CF_DISABLE_SPU_COLLISION_PROCESSING);
<a name="l00499"></a>00499       <a class="code" href="class_game_physics_engine.html#aae5433ee5d9f4f4c8374f7782ee52d75" title="flag to indicate simulation">doingSimulationInAir</a> = 1;
<a name="l00500"></a>00500 
<a name="l00501"></a>00501       <span class="comment">//std::cout&lt;&lt;&quot;doing simulation:\n&quot;&lt;&lt;doingSimulationInAir;</span>
<a name="l00502"></a>00502 
<a name="l00503"></a>00503     }
<a name="l00504"></a>00504     <span class="keywordflow">else</span> <span class="keywordflow">if</span>((obA-&gt;getUserPointer() == <a class="code" href="class_game_physics_engine.html#af514ddb7f22288d2d6da48ce1e89c822" title="pointer to determine the collison shape">grenadeptr</a>) &amp;&amp; (obA-&gt;getCollisionShape()-&gt;getShapeType() == CONVEX_HULL_SHAPE_PROXYTYPE) &amp;&amp; (obB-&gt;getCollisionShape()-&gt;getShapeType() == STATIC_PLANE_PROXYTYPE))
<a name="l00505"></a>00505 
<a name="l00506"></a>00506     {
<a name="l00507"></a>00507         obA-&gt;setCollisionFlags(btCollisionObject::CF_DISABLE_SPU_COLLISION_PROCESSING);
<a name="l00508"></a>00508         <a class="code" href="class_game_physics_engine.html#aae5433ee5d9f4f4c8374f7782ee52d75" title="flag to indicate simulation">doingSimulationInAir</a> = 0;
<a name="l00509"></a>00509      }
<a name="l00510"></a>00510 
<a name="l00511"></a>00511   }
<a name="l00512"></a>00512 
<a name="l00513"></a>00513   <span class="comment">//std::cout&lt;&lt;&quot;number of contacts is &quot;&lt;&lt; numContacts&lt;&lt;std::endl;</span>
<a name="l00514"></a>00514 }
<a name="l00515"></a>00515 
<a name="l00516"></a>00516 
<a name="l00517"></a>00517 
<a name="l00518"></a>00518 
<a name="l00519"></a><a class="code" href="class_game_physics_engine.html#a2729eba373dffed2dd0164dc88ee8d1e">00519</a> <span class="keywordtype">bool</span> <a class="code" href="class_game_physics_engine.html#a2729eba373dffed2dd0164dc88ee8d1e" title="gets the simulation flag">GamePhysicsEngine::getSimulationFlag</a>()
<a name="l00520"></a>00520 {
<a name="l00521"></a>00521   <span class="keywordflow">return</span> <a class="code" href="class_game_physics_engine.html#aae5433ee5d9f4f4c8374f7782ee52d75" title="flag to indicate simulation">doingSimulationInAir</a>;
<a name="l00522"></a>00522 }
<a name="l00523"></a>00523 
<a name="l00524"></a>00524 <span class="comment">//grenade obstacle collision count</span>
<a name="l00525"></a><a class="code" href="class_game_physics_engine.html#a3a8380a8fb5387d5548eae4a50f6041b">00525</a> <span class="keywordtype">void</span> <a class="code" href="class_game_physics_engine.html#a3a8380a8fb5387d5548eae4a50f6041b" title="sets the grenade obstacle count value used for scoring">GamePhysicsEngine::setGrenadeObstacleCcount</a>(<span class="keywordtype">int</span> _noOfLives)
<a name="l00526"></a>00526 {
<a name="l00527"></a>00527     <span class="keywordflow">if</span>(_noOfLives == 0)
<a name="l00528"></a>00528     {
<a name="l00529"></a>00529      <a class="code" href="class_game_physics_engine.html#a7f8cae1aa77d053b7c843457592e01dc" title="pointer to determine the collison shape">grenadeObstacleCcount</a>-=0.01;
<a name="l00530"></a>00530     }
<a name="l00531"></a>00531     <span class="keywordflow">else</span>
<a name="l00532"></a>00532     {
<a name="l00533"></a>00533         <a class="code" href="class_game_physics_engine.html#a7f8cae1aa77d053b7c843457592e01dc" title="pointer to determine the collison shape">grenadeObstacleCcount</a> = _noOfLives;
<a name="l00534"></a>00534     }
<a name="l00535"></a>00535 
<a name="l00536"></a>00536     std::cout&lt;&lt;<span class="stringliteral">&quot;life of the grenade is &quot;</span>&lt;&lt;<a class="code" href="class_game_physics_engine.html#a7f8cae1aa77d053b7c843457592e01dc" title="pointer to determine the collison shape">grenadeObstacleCcount</a>;
<a name="l00537"></a>00537 }
<a name="l00538"></a>00538 
<a name="l00539"></a>00539 
<a name="l00540"></a><a class="code" href="class_game_physics_engine.html#adc49e1c75ddc169e495dc8830b70bf51">00540</a> <span class="keywordtype">float</span> <a class="code" href="class_game_physics_engine.html#adc49e1c75ddc169e495dc8830b70bf51" title="gets the obstacle count value used for scoring">GamePhysicsEngine::getGrenadeObstacleCcount</a>()
<a name="l00541"></a>00541 {
<a name="l00542"></a>00542     <span class="keywordflow">return</span> <a class="code" href="class_game_physics_engine.html#a7f8cae1aa77d053b7c843457592e01dc" title="pointer to determine the collison shape">grenadeObstacleCcount</a>;
<a name="l00543"></a>00543 }
<a name="l00544"></a>00544 
<a name="l00545"></a>00545 
<a name="l00546"></a>00546 
<a name="l00547"></a>00547 
<a name="l00548"></a><a class="code" href="class_game_physics_engine.html#a39280c8be4b9320e672778fe95b90956">00548</a> <span class="keywordtype">void</span> <a class="code" href="class_game_physics_engine.html#a39280c8be4b9320e672778fe95b90956" title="sets the game won flag when grande hits amunition box">GamePhysicsEngine::setGameWonFlag</a>()
<a name="l00549"></a>00549 {
<a name="l00550"></a>00550     <span class="comment">// a hit on the goal (crate box) has been detected, set the flag which will be queried by the game logic to let the user know that the game has been won</span>
<a name="l00551"></a>00551     <a class="code" href="class_game_physics_engine.html#aa2a56ae08a11708c47aa0ea83fdc658e" title="game won flag when grenade hits ammunition">gameWonFlag</a> = <span class="keyword">true</span>;
<a name="l00552"></a>00552 }
<a name="l00553"></a>00553 
<a name="l00554"></a><a class="code" href="class_game_physics_engine.html#a92d0a1eab2520787fb12d8d67819b4ce">00554</a> <span class="keywordtype">bool</span> <a class="code" href="class_game_physics_engine.html#a92d0a1eab2520787fb12d8d67819b4ce" title="get the game won flag if grenade hits the ammunition">GamePhysicsEngine::getGameWonFlag</a>()
<a name="l00555"></a>00555 {
<a name="l00556"></a>00556     <span class="keywordflow">return</span> <a class="code" href="class_game_physics_engine.html#aa2a56ae08a11708c47aa0ea83fdc658e" title="game won flag when grenade hits ammunition">gameWonFlag</a>;
<a name="l00557"></a>00557 }
</pre></div></div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 28 Mar 2013 for GRENADE GAME by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
